//////////////////////////////////////////////////////////////////////////////
//
//  For instantiating the scene models.
//
//  J. Madeira - November 2018
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
//  Constructors
//
var map;
var mapChoice = 0;

var maze = {
	map: [],
	height: 0,
	width: 0,
	init: function(structure, height, width) {
		this.map = structure;
		this.height = height;
		this.width = width;
	},
};

function initiateMaze(variable) {
	if (variable == 0) {
		map = [
			[1,1,1,1,1,1,1,1,1,1,1,2,1],
			[1,0,0,0,1,1,0,0,0,0,1,0,1],
			[1,0,1,0,1,1,0,1,1,1,1,0,1],
			[1,0,1,0,1,1,0,0,0,1,0,0,1],
			[1,0,0,0,0,1,0,1,0,0,0,1,1],
			[1,0,1,1,1,1,1,0,1,1,1,1,1],
			[1,0,1,0,0,0,1,0,0,0,0,0,1],
			[1,0,1,1,0,0,1,0,0,0,1,0,1],
			[1,0,0,0,0,1,1,1,1,1,1,0,1],
			[1,0,0,0,0,1,0,0,0,0,0,0,1],
			[1,0,1,1,0,1,0,1,1,1,1,1,1],
			[1,0,0,0,0,1,0,0,0,0,0,0,1],
			[1,0,1,1,0,1,1,1,1,1,1,0,1],
			[1,0,0,0,0,0,0,0,0,0,0,0,1],
			[1,1,1,1,1,1,1,1,1,1,1,1,1],
		];
	}
	else if (variable === 1)
	{
		map = [
			[1,1,1,1,1,1,1,1,1,1,1,2,1],
			[1,0,0,0,0,1,0,0,0,0,1,0,1],
			[1,1,0,1,0,0,0,1,1,1,1,0,1],
			[1,1,0,1,0,1,0,0,0,0,0,0,1],
			[1,1,0,1,0,1,0,1,1,1,1,1,1],
			[1,0,0,1,0,1,0,0,1,0,0,0,1],
			[1,0,1,1,0,1,1,1,1,0,1,0,1],
			[1,0,0,1,0,1,0,1,0,0,1,0,1],
			[1,1,0,1,0,0,0,0,0,0,1,0,1],
			[1,1,0,1,1,1,1,1,1,0,1,0,1],
			[1,0,0,0,0,0,0,0,0,0,0,0,1],
			[1,1,1,1,1,1,0,1,1,1,1,1,1],
			[1,0,0,0,0,1,0,0,1,0,0,0,1],
			[1,0,1,1,0,1,1,0,1,1,1,0,1],
			[1,0,0,0,0,0,0,0,0,0,0,0,1],
			[1,1,1,1,1,1,1,1,1,1,1,1,1],
		];
	}
	else if (variable === 2)
	{
		map = [
			[1,1,1,1,1,1,1,1,1,1,1,2,1],
			[1,0,0,0,0,1,0,0,0,0,0,0,1],
			[1,0,1,0,1,1,0,1,1,1,1,1,1],
			[1,0,1,0,0,1,0,0,0,0,0,0,1],
			[1,0,0,0,0,1,0,0,0,0,0,0,1],
			[1,0,0,1,1,1,0,1,1,1,1,1,1],
			[1,1,1,0,0,0,0,0,0,0,1,0,1],
			[1,1,1,1,0,0,0,0,0,0,1,0,1],
			[1,0,0,0,0,1,1,1,1,1,1,0,1],
			[1,0,0,0,0,1,0,0,0,0,0,0,1],
			[1,0,1,1,0,1,0,1,1,1,1,1,1],
			[1,0,0,0,0,1,0,0,0,0,0,0,1],
			[1,0,1,1,0,1,1,1,1,1,1,0,1],
			[1,0,0,0,0,0,0,0,0,0,0,0,1],
			[1,0,0,0,0,1,0,0,0,0,1,0,1],
			[1,1,0,1,0,0,0,1,1,1,1,0,1],
			[1,1,0,1,0,1,0,0,0,0,0,0,1],
			[1,1,0,1,0,1,0,1,1,1,1,1,1],
			[1,0,0,1,0,1,0,0,1,0,0,0,1],
			[1,0,1,1,0,1,1,1,1,0,1,0,1],
			[1,0,0,1,0,1,0,1,0,0,1,0,1],
			[1,1,0,1,0,0,0,0,0,0,1,0,1],
			[1,1,0,1,1,1,1,1,1,0,1,0,1],
			[1,0,0,0,0,0,0,0,0,0,0,0,1],
			[1,1,1,1,1,1,0,1,1,1,1,1,1],
			[1,0,0,0,0,1,0,0,1,0,0,0,1],
			[1,0,1,1,0,1,1,0,1,1,1,0,1],
			[1,0,0,0,0,0,0,0,0,0,0,0,1],
			[1,1,1,1,1,1,1,1,1,1,1,1,1],
		];
	}
	else
	{
		map =[ [1,1,1,1,1,1,1,1,1,1,1,2,1],
			[1,0,0,0,0,1,0,0,0,0,0,0,1],
			[1,0,1,0,1,1,0,1,1,1,1,1,1],
			[1,0,1,0,0,1,0,0,0,0,0,0,1],
			[1,0,0,0,0,1,0,0,0,0,0,0,1],
			[1,0,0,1,1,1,0,1,1,1,1,1,1],
			[1,1,1,0,0,0,0,0,0,0,1,0,1],
			[1,1,1,1,0,0,0,1,0,1,1,0,1],
			[1,0,1,0,0,1,1,1,1,1,0,0,1],
			[1,0,1,0,0,1,0,0,0,0,0,0,1],
			[1,0,1,1,0,1,1,1,1,0,1,1,1],
			[1,0,0,1,0,0,0,0,0,0,0,0,1],
			[1,0,1,1,0,1,1,1,1,1,1,0,1],
			[1,0,0,0,0,1,0,0,0,0,1,0,1],
			[1,1,0,1,0,0,0,1,1,1,1,0,1],
			[1,0,0,1,0,1,0,0,0,0,0,0,1],
			[1,1,0,1,0,1,0,1,1,1,1,1,1],
			[1,0,0,1,0,1,0,0,1,0,0,0,1],
			[1,0,1,1,0,1,1,1,1,0,1,0,1],
			[1,0,0,1,0,1,0,1,0,0,1,0,1],
			[1,1,0,1,0,0,0,0,0,0,1,0,1],
			[1,1,0,1,1,1,1,1,1,0,1,0,1],
			[1,0,0,0,0,1,0,0,1,0,0,0,1],
			[1,0,1,1,0,1,1,0,1,1,1,0,1],
			[1,0,0,0,0,0,0,0,0,0,0,0,1],
			[1,1,1,1,1,1,1,1,1,1,1,1,1] ];
	}

	var width = map[0].length;
	var height = map.length;

	maze.init(map, height, width);

	var mapInversed = [];

	for(var d=map.length-1; d>=0; d--)
	{
		mapInversed.push(maze.map[d]);
	}

	maze.map = mapInversed;
}

var sceneModels = [];

function emptyModelFeatures() {

	// EMPTY MODEL

	this.vertices = [];

	this.normals = [];

	// Transformation parameters

	// Displacement vector
	
	this.tx = 0.0;
	
	this.ty = 0.0;
	
	this.tz = 0.0;

	// Scaling factors
	
	this.sx = 0.5;
	
	this.sy = 0.5;
	
	this.sz = 0.5;

	
	// Material features
	
	this.kAmbi = [ 0.2, 0.2, 0.2 ];
	
	this.kDiff = [ 0.7, 0.7, 0.7 ];

	this.kSpec = [ 0.7, 0.7, 0.7 ];

	this.nPhong = 100;

}

function simpleCubeModel( ) {
	
	var cube = new emptyModelFeatures();

	cube.vertices = [

		-1.000000, -1.000000,  1.000000, 
		 1.000000,  1.000000,  1.000000, 
		-1.000000,  1.000000,  1.000000, 
		-1.000000, -1.000000,  1.000000,
		 1.000000, -1.000000,  1.000000, 
		 1.000000,  1.000000,  1.000000, 
         1.000000, -1.000000,  1.000000, 
		 1.000000, -1.000000, -1.000000, 
		 1.000000,  1.000000, -1.000000, 
         1.000000, -1.000000,  1.000000, 
         1.000000,  1.000000, -1.000000, 
         1.000000,  1.000000,  1.000000, 
        -1.000000, -1.000000, -1.000000, 
        -1.000000,  1.000000, -1.000000,
         1.000000,  1.000000, -1.000000, 
        -1.000000, -1.000000, -1.000000, 
         1.000000,  1.000000, -1.000000, 
         1.000000, -1.000000, -1.000000, 
        -1.000000, -1.000000, -1.000000, 
		-1.000000, -1.000000,  1.000000, 
		-1.000000,  1.000000, -1.000000, 
		-1.000000, -1.000000,  1.000000, 
		-1.000000,  1.000000,  1.000000, 
		-1.000000,  1.000000, -1.000000, 
		-1.000000,  1.000000, -1.000000, 
		-1.000000,  1.000000,  1.000000, 
		 1.000000,  1.000000, -1.000000, 
		-1.000000,  1.000000,  1.000000, 
		 1.000000,  1.000000,  1.000000, 
		 1.000000,  1.000000, -1.000000, 
		-1.000000, -1.000000,  1.000000, 
		-1.000000, -1.000000, -1.000000,
		 1.000000, -1.000000, -1.000000, 
		-1.000000, -1.000000,  1.000000, 
		 1.000000, -1.000000, -1.000000, 
		 1.000000, -1.000000,  1.000000, 	 
	];

	computeVertexNormals( cube.vertices, cube.normals );

	return cube;
}

function cubeModel( subdivisionDepth = 0 ) {
	
	var cube = new simpleCubeModel();
	
	midPointRefinement( cube.vertices, subdivisionDepth );
	
	computeVertexNormals( cube.vertices, cube.normals );
	
	return cube;
}


//----------------------------------------------------------------------------
//
//  Instantiating scene models
//

initiateMaze(mapChoice = 3);

// Model 0 --- Top Left
var aux1 = 0;

for(var i = 0; i < maze.height ; i++)
{
	var line = maze.map[i];
	for (var j=0; j < maze.width; j++)
	{
		if(line[j] == 1)
		{
			// 1 means it is a wall block so we build a cube with a bigger hight that is double the hight
			// of the cube
			sceneModels.push( new cubeModel() );
			sceneModels[aux1].tx = (j) + 0.5;
			sceneModels[aux1].ty = (i) + 0.5;
			sceneModels[aux1].sz = 6.8;
			sceneModels[aux1].kAmb = [ 0.25, 0.22, 0.06];
			sceneModels[aux1].kDiff = [ 0.35, 0.31, 0.09];
			sceneModels[aux1].kSpec = [0.8, 0.73, 0.21];
			sceneModels[aux1].nPhong = 83.2;
			aux1++;
		}
		else if(line[j] == 2)
		{
			// 0 means it is a end block so we only build a cube
			sceneModels.push( new cubeModel() );
			sceneModels[aux1].tx = (j) + 0.5;
			sceneModels[aux1].ty = (i) + 0.5;
			sceneModels[aux1].sz = 6.8;
			sceneModels[aux1].kDiff = [ 1, 1, 1 ];
			aux1++;
		}
	}
}

// 0 means it is a floor block so we only build a cube
sceneModels.push( new cubeModel() );
sceneModels[aux1].tx = maze.width/2;
sceneModels[aux1].ty = maze.height/2;
sceneModels[aux1].sx = maze.width/2;
sceneModels[aux1].sy = maze.height/2;
sceneModels[aux1].sz = 0.3;
sceneModels[aux1].kAmbi = [ 0.1, 0.1, 0.1 ];
sceneModels[aux1].kDiff = [ 0.5, 0.5, 0.5 ];
sceneModels[aux1].kSpec = [ 0.7, 0.7, 0.7 ];



